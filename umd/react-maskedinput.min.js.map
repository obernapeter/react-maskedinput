{"version":3,"sources":["webpack://MaskedInput/webpack/universalModuleDefinition","webpack://MaskedInput/webpack/bootstrap","webpack://MaskedInput/external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","webpack://MaskedInput/./node_modules/inputmask-core/lib/index.js","webpack://MaskedInput/./src/index.js"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","extend","dest","src","props","keys","length","copy","obj","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","DEFAULT_FORMAT_CHARACTERS","validate","char","test","transform","toUpperCase","Pattern","source","formatCharacters","placeholderChar","isRevealingMask","this","pattern","firstEditableIndex","lastEditableIndex","_editableIndices","_parse","InputMask","options","selection","start","end","Error","merged","chars","mergeFormatCharacters","setPattern","sourceChars","split","patternIndex","push","formatValue","valueBuffer","Array","valueIndex","isEditableIndex","isValidAtIndex","index","format","input","selectionBefore","valueBefore","getValue","inputIndex","_historyIndex","_history","splice","_lastOp","_lastSelection","lastOp","backspace","paste","initialState","slice","charAt","substring","undo","historyItem","startUndo","redo","pop","setValue","emptyValue","join","_resetHistory","setSelection","getRawValue","rawValue","isUndo","e","ctrlKey","metaKey","keyCode","shiftKey","isRedo","getSelection","el","undefined","selectionStart","selectionEnd","focus","rangeEl","createTextRange","clone","duplicate","moveToBookmark","document","createRange","getBookmark","setEndPoint","text","MaskedInput","maskValue","mask","incomingValue","target","_updateMaskSelection","_getDisplayValue","_updateInputSelection","onChange","preventDefault","altKey","data","clipboardData","getData","setTimeout","UNSAFE_componentWillMount","UNSAFE_componentWillReceiveProps","nextProps","UNSAFE_componentWillUpdate","nextState","_updatePattern","componentDidUpdate","prevProps","setSelectionRange","collapse","moveStart","moveEnd","select","_keyPressPropName","navigator","userAgent","match","_getEventHandlers","_onChange","onKeyDown","_onKeyDown","onPaste","_onPaste","_onKeyPress","blur","render","maxLength","eventHandlers","size","placeholder","inputProps","ref","React","Component"],"mappings":"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","file":"react-maskedinput.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MaskedInput\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"MaskedInput\"] = factory(root[\"React\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","'use strict'\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n","import React from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport InputMask from 'inputmask-core'\r\n\r\nlet KEYCODE_Z = 90\r\nlet KEYCODE_Y = 89\r\n\r\nfunction isUndo(e) {\r\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Y : KEYCODE_Z)\r\n}\r\n\r\nfunction isRedo(e) {\r\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Z : KEYCODE_Y)\r\n}\r\n\r\nfunction getSelection (el) {\r\n  let start, end\r\n  if (el.selectionStart !== undefined) {\r\n    start = el.selectionStart\r\n    end = el.selectionEnd\r\n  }\r\n  else {\r\n    try {\r\n      el.focus()\r\n      let rangeEl = el.createTextRange()\r\n      let clone = rangeEl.duplicate()\r\n\r\n      rangeEl.moveToBookmark(document.selection.createRange().getBookmark())\r\n      clone.setEndPoint('EndToStart', rangeEl)\r\n\r\n      start = clone.text.length\r\n      end = start + rangeEl.text.length\r\n    }\r\n    catch (e) { /* not focused or not visible */ }\r\n  }\r\n\r\n  return { start, end }\r\n}\r\n\r\nfunction setSelection(el, selection) {\r\n  try {\r\n    if (el.selectionStart !== undefined) {\r\n      el.focus()\r\n      el.setSelectionRange(selection.start, selection.end)\r\n    }\r\n    else {\r\n      el.focus()\r\n      let rangeEl = el.createTextRange()\r\n      rangeEl.collapse(true)\r\n      rangeEl.moveStart('character', selection.start)\r\n      rangeEl.moveEnd('character', selection.end - selection.start)\r\n      rangeEl.select()\r\n    }\r\n  }\r\n  catch (e) { /* not focused or not visible */ }\r\n}\r\n\r\nclass MaskedInput extends React.Component {\r\n  static propTypes = {\r\n    mask: PropTypes.string.isRequired,\r\n\r\n    formatCharacters: PropTypes.object,\r\n    placeholderChar: PropTypes.string\r\n  }\r\n\r\n  static defaultProps = {\r\n    value: ''\r\n  }\r\n\r\n  /* eslint-disable camelcase */\r\n  UNSAFE_componentWillMount() {\r\n    let options = {\r\n      pattern: this.props.mask,\r\n      value: this.props.value,\r\n      formatCharacters: this.props.formatCharacters\r\n    }\r\n    if (this.props.placeholderChar) {\r\n      options.placeholderChar = this.props.placeholderChar\r\n    }\r\n    this.mask = new InputMask(options)\r\n  }\r\n\r\n  /* eslint-disable camelcase */\r\n  UNSAFE_componentWillReceiveProps(nextProps) {\r\n    if (this.props.mask !== nextProps.mask && this.props.value !== nextProps.mask) {\r\n      // if we get a new value and a new mask at the same time\r\n      // check if the mask.value is still the initial value\r\n      // - if so use the nextProps value\r\n      // - otherwise the `this.mask` has a value for us (most likely from paste action)\r\n      if (this.mask.getValue() === this.mask.emptyValue) {\r\n        this.mask.setPattern(nextProps.mask, {value: nextProps.value})\r\n      }\r\n      else {\r\n        this.mask.setPattern(nextProps.mask, {value: this.mask.getRawValue()})\r\n      }\r\n    }\r\n    else if (this.props.mask !== nextProps.mask) {\r\n      this.mask.setPattern(nextProps.mask, {value: this.mask.getRawValue()})\r\n    }\r\n    else if (this.props.value !== nextProps.value) {\r\n      this.mask.setValue(nextProps.value)\r\n    }\r\n  }\r\n\r\n  /* eslint-disable camelcase */\r\n  UNSAFE_componentWillUpdate(nextProps, nextState) {\r\n    if (nextProps.mask !== this.props.mask) {\r\n      this._updatePattern(nextProps)\r\n    }\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.mask !== this.props.mask && this.mask.selection.start) {\r\n      this._updateInputSelection()\r\n    }\r\n  }\r\n\r\n  _updatePattern(props) {\r\n    this.mask.setPattern(props.mask, {\r\n      value: this.mask.getRawValue(),\r\n      selection: getSelection(this.input)\r\n    })\r\n  }\r\n\r\n  _updateMaskSelection() {\r\n    this.mask.selection = getSelection(this.input)\r\n  }\r\n\r\n  _updateInputSelection() {\r\n    setSelection(this.input, this.mask.selection)\r\n  }\r\n\r\n  _onChange = (e) => {\r\n    // console.log('onChange', JSON.stringify(getSelection(this.input)), e.target.value)\r\n\r\n    let maskValue = this.mask.getValue()\r\n    let incomingValue = e.target.value\r\n    if (incomingValue !== maskValue) { // only modify mask if form contents actually changed\r\n      this._updateMaskSelection()\r\n      this.mask.setValue(incomingValue) // write the whole updated value into the mask\r\n      e.target.value = this._getDisplayValue() // update the form with pattern applied to the value\r\n      this._updateInputSelection()\r\n    }\r\n\r\n    if (this.props.onChange) {\r\n      this.props.onChange(e)\r\n    }\r\n  }\r\n\r\n  _onKeyDown = (e) => {\r\n    // console.log('onKeyDown', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\r\n\r\n    if (isUndo(e)) {\r\n      e.preventDefault()\r\n      if (this.mask.undo()) {\r\n        e.target.value = this._getDisplayValue()\r\n        this._updateInputSelection()\r\n        if (this.props.onChange) {\r\n          this.props.onChange(e)\r\n        }\r\n      }\r\n      return\r\n    }\r\n    else if (isRedo(e)) {\r\n      e.preventDefault()\r\n      if (this.mask.redo()) {\r\n        e.target.value = this._getDisplayValue()\r\n        this._updateInputSelection()\r\n        if (this.props.onChange) {\r\n          this.props.onChange(e)\r\n        }\r\n      }\r\n      return\r\n    }\r\n\r\n    if (e.key === 'Backspace') {\r\n      e.preventDefault()\r\n      this._updateMaskSelection()\r\n      if (this.mask.backspace()) {\r\n        let value = this._getDisplayValue()\r\n        e.target.value = value\r\n        if (value) {\r\n          this._updateInputSelection()\r\n        }\r\n        if (this.props.onChange) {\r\n          this.props.onChange(e)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _onKeyPress = (e) => {\r\n    // console.log('onKeyPress', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\r\n\r\n    // Ignore modified key presses\r\n    // Ignore enter key to allow form submission\r\n    if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') { return }\r\n\r\n    e.preventDefault()\r\n    this._updateMaskSelection()\r\n    if (this.mask.input((e.key || e.data))) {\r\n      e.target.value = this.mask.getValue()\r\n      this._updateInputSelection()\r\n      if (this.props.onChange) {\r\n        this.props.onChange(e)\r\n      }\r\n    }\r\n  }\r\n\r\n  _onPaste = (e) => {\r\n    // console.log('onPaste', JSON.stringify(getSelection(this.input)), e.clipboardData.getData('Text'), e.target.value)\r\n\r\n    e.preventDefault()\r\n    this._updateMaskSelection()\r\n    // getData value needed for IE also works in FF & Chrome\r\n    if (this.mask.paste(e.clipboardData.getData('Text'))) {\r\n      e.target.value = this.mask.getValue()\r\n      // Timeout needed for IE\r\n      setTimeout(() => this._updateInputSelection(), 0)\r\n      if (this.props.onChange) {\r\n        this.props.onChange(e)\r\n      }\r\n    }\r\n  }\r\n\r\n  _getDisplayValue() {\r\n    let value = this.mask.getValue()\r\n    return value === this.mask.emptyValue ? '' : value\r\n  }\r\n\r\n  _keyPressPropName() {\r\n    if (typeof navigator !== 'undefined') {\r\n      return navigator.userAgent.match(/Android/i)\r\n      ? 'onBeforeInput'\r\n      : 'onKeyPress'\r\n    }\r\n    return 'onKeyPress'\r\n  }\r\n\r\n  _getEventHandlers() {\r\n    return {\r\n      onChange: this._onChange,\r\n      onKeyDown: this._onKeyDown,\r\n      onPaste: this._onPaste,\r\n      [this._keyPressPropName()]: this._onKeyPress\r\n    }\r\n  }\r\n\r\n  focus() {\r\n    this.input.focus()\r\n  }\r\n\r\n  blur() {\r\n    this.input.blur()\r\n  }\r\n\r\n  render() {\r\n    let ref = r => { this.input = r }\r\n    let maxLength = this.mask.pattern.length\r\n    let value = this._getDisplayValue()\r\n    let eventHandlers = this._getEventHandlers()\r\n    let { size = maxLength, placeholder = this.mask.emptyValue } = this.props\r\n\r\n    let { placeholderChar, formatCharacters, ...cleanedProps } = this.props // eslint-disable-line no-unused-vars\r\n    let inputProps = { ...cleanedProps, ...eventHandlers, ref, maxLength, value, size, placeholder }\r\n    return <input {...inputProps} />\r\n  }\r\n}\r\n\r\nexport default MaskedInput\r\n"],"sourceRoot":""}